package jp.trap.conqest.game

import jp.trap.conqest.Main
import jp.trap.conqest.util.Partition
import net.kyori.adventure.text.Component
import net.kyori.adventure.text.format.NamedTextColor
import org.bukkit.Bukkit
import org.bukkit.Location
import org.bukkit.Material
import org.bukkit.block.data.BlockData
import org.bukkit.entity.Player
import java.util.*

class Field(
    val plugin: Main, val creatorId: UUID, val center: Location, val partition: Partition, val roadWidth: Double = 3.0
) {

    object Materials {
        val wall = Material.BEDROCK
        val core = Material.BEACON
        val coreBase = Material.IRON_BLOCK
        val fence = Material.STONE_BRICK_WALL
        val road = Material.DIRT_PATH
    }

    private val previewBlockLocations = mutableSetOf<Location>()

    init {
        require(roadWidth > 0.0) { "roadWidth must be positive" }

        partition.printRoadWidth = roadWidth
    }

    fun bottom(): Int = center.blockX - partition.fieldSize.first / 2

    fun top(): Int = bottom() + partition.fieldSize.first

    fun left(): Int = center.blockZ - partition.fieldSize.second / 2

    fun right(): Int = left() + partition.fieldSize.second

    fun showPreview(target: Player, radius: Int = 32) {
        val blockChanges = mutableMapOf<Location, BlockData>()

        val targetX = target.location.blockX - bottom()
        val targetZ = target.location.blockZ - left()

        // around the target player
        for (i in maxOf(-1, targetX - radius) until minOf(partition.fieldSize.first + 1, targetX + radius)) {
            for (j in maxOf(-1, targetZ - radius) until minOf(partition.fieldSize.second + 1, targetZ + radius)) {
                val ground = target.world.getHighestBlockAt(bottom() + i, left() + j)
                val groundLoc = ground.location

                val districtIndex = partition.getDistrictIndex(i to j)

                // wall
                if (districtIndex == null) {
                    for (k in -32 until 32) {
                        val loc = groundLoc.clone().add(0.0, k.toDouble(), 0.0)
                        if (loc.blockY < loc.world.minHeight || loc.blockY > loc.world.maxHeight) break
                        if (previewBlockLocations.contains(loc)) continue
                        blockChanges[loc] = Materials.wall.createBlockData()
                    }
                }

                if (partition.isCenter(i to j)) {
                    // core
                    val coreLoc = groundLoc.clone().add(0.0, 1.0, 0.0)
                    for (x in -1..1) for (z in -1..1) {
                        blockChanges[coreLoc.clone().add(x.toDouble(), -1.0, z.toDouble())] =
                            Materials.coreBase.createBlockData()
                    }
                    blockChanges[coreLoc] = Materials.core.createBlockData()
                } else if (partition.inRoad(i to j, roadWidth)) {
                    // road
                    if (!previewBlockLocations.contains(groundLoc)) {
                        blockChanges[groundLoc] = Materials.road.createBlockData()
                    }
                } else if (partition.getBorderLevel(i to j) >= 1) {
                    // fence
                    val loc = groundLoc.clone().add(0.0, 1.0, 0.0)
                    if (!previewBlockLocations.contains(loc)) {
                        blockChanges[loc] = Materials.fence.createBlockData()
                    }
                }
            }
        }

        target.sendMultiBlockChange(blockChanges)
        previewBlockLocations.addAll(blockChanges.keys)
    }

    fun hidePreview() = previewBlockLocations.forEach { it.block.state.update(false, false) }

    fun generate() {
        // TODO: generate
        Bukkit.getEntity(creatorId)?.sendMessage(Component.text("TODO: confirm", NamedTextColor.GOLD))

        with(plugin.logger) {
            info("-".repeat(40))
            info("Field generated by $creatorId")
            info("  X: ${bottom()} to ${top()}")
            info("  Z: ${left()} to ${right()}")
            partition.toString().split("\n").forEach { info(it) }
            info("-".repeat(40))
        }

    }

}
