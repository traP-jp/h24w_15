package jp.trap.conqest.game

import jp.trap.conqest.Main
import jp.trap.conqest.util.Partition
import net.kyori.adventure.text.Component
import net.kyori.adventure.text.format.NamedTextColor
import org.bukkit.Bukkit
import org.bukkit.Location
import org.bukkit.Material
import org.bukkit.Tag
import org.bukkit.block.data.BlockData
import org.bukkit.entity.Player
import java.util.*

class Field(
    val plugin: Main, val creatorId: UUID, val center: Location, val partition: Partition, val roadWidth: Double = 3.0
) {

    object Materials {
        val wall = Material.BEDROCK
        val core = Material.BEACON
        val coreBase = Material.IRON_BLOCK
        val fence = Material.STONE_BRICK_WALL
        val road = Material.DIRT_PATH
    }

    private val blockChanges = mutableMapOf<Location, BlockData>()

    init {
        require(roadWidth > 0.0) { "roadWidth must be positive" }

        partition.printRoadWidth = roadWidth

        Bukkit.getPlayer(creatorId)?.let { showPreview(it) }
    }

    fun bottom(): Int = center.blockX - partition.fieldSize.first / 2

    fun top(): Int = bottom() + partition.fieldSize.first

    fun left(): Int = center.blockZ - partition.fieldSize.second / 2

    fun right(): Int = left() + partition.fieldSize.second

    fun showPreview(target: Player) {
        hidePreview()
        blockChanges.clear()

        // wall
        forEachGrounds(target) { position, ground ->
            if (partition.getDistrictIndex(position) != null) return@forEachGrounds
            ground.y = target.world.minHeight.toDouble()
            while (ground.y <= target.world.maxHeight) {
                blockChanges[ground.clone()] = Materials.wall.createBlockData()
                ground.y += 1.0
            }
        }

        // remove tree
        forEachGrounds(target) { _, ground ->
            while (ground.blockY - 1 >= target.world.minHeight && checkIsTree(getChangedBlockData(ground).material)) {
                blockChanges[ground.clone()] = Material.AIR.createBlockData()
                ground.y -= 1.0
            }
        }

        // cover liquid with glass
        forEachGrounds(target) { _, ground ->
            when (getChangedBlockData(ground).material) {
                Material.WATER -> blockChanges[ground] = Material.LIGHT_BLUE_STAINED_GLASS.createBlockData()
                Material.LAVA -> blockChanges[ground] = Material.ORANGE_STAINED_GLASS.createBlockData()
                else -> {}
            }
        }

        // road
        forEachGrounds(target) { position, ground ->
            if (!partition.inRoad(position, roadWidth)) return@forEachGrounds
            blockChanges[ground] = Materials.road.createBlockData()
        }

        // fence
        forEachGrounds(target) { position, ground ->
            if (partition.getBorderLevel(position) < 1) return@forEachGrounds
            if (partition.inRoad(position, roadWidth)) return@forEachGrounds
            blockChanges[ground.clone().add(0.0, 1.0, 0.0)] = Materials.fence.createBlockData()
        }

        // core
        forEachGrounds(target) { position, ground ->
            if (!partition.isCenter(position)) return@forEachGrounds
            val coreLoc = ground.add(0.0, 1.0, 0.0)
            for (x in -1..1) for (z in -1..1) {
                blockChanges[coreLoc.clone().add(x.toDouble(), -1.0, z.toDouble())] =
                    Materials.coreBase.createBlockData()
            }
            blockChanges[coreLoc] = Materials.core.createBlockData()
        }

        target.sendMultiBlockChange(blockChanges)
        target.sendMessage("Previewing at $center")
    }

    fun hidePreview() = blockChanges.keys.forEach { it.block.state.update(false, false) }

    fun generate() {
        // TODO: generate
        Bukkit.getEntity(creatorId)?.sendMessage(Component.text("TODO: confirm", NamedTextColor.GOLD))

        with(plugin.logger) {
            info("-".repeat(40))
            info("Field generated by $creatorId")
            info("  X: ${bottom()} to ${top()}")
            info("  Z: ${left()} to ${right()}")
            partition.toString().split("\n").forEach { info(it) }
            info("-".repeat(40))
        }

    }

    private fun checkIsTree(material: Material): Boolean {
        return Tag.LOGS.isTagged(material) || Tag.LEAVES.isTagged(material) || material == Material.BEE_NEST
    }

    private fun getChangedBlockData(loc: Location): BlockData = blockChanges[loc] ?: loc.block.blockData

    private fun forEachGrounds(
        target: Player, action: (position: Pair<Int, Int>, ground: Location) -> Unit
    ) {
        for (i in -1 until partition.fieldSize.first + 1) {
            for (j in -1 until partition.fieldSize.second + 1) {
                val ground = target.world.getHighestBlockAt(bottom() + i, left() + j).location
                while (ground.blockY - 1 >= target.world.minHeight) {
                    val blockData = getChangedBlockData(ground)
                    if (blockData.material.isCollidable) break
                    if (blockData.material == Material.WATER || blockData.material == Material.LAVA) break
                    ground.add(0.0, -1.0, 0.0)
                }
                action(i to j, ground)
            }
        }
    }

}
